<!DOCTYPE html>
<html lang="en">
<head>
    <title>AURALIS VR Experience</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="AURALIS: Step Into Sound and Light. An immersive VR music and video performance by Wang Meng and Yu Miao.">
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; overflow: hidden; background-color: #000; color: #fff; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #vr-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; display: flex; justify-content: center; align-items: center; font-size: 1.5em; z-index: 100; transition: opacity 1s ease-out; }
        #loading-screen.fade-out { opacity: 0; pointer-events: none; } /* Hide after fade */
        canvas { display: block; }
    </style>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- VR Button -->
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/webxr/VRButton.js"></script>
    <!-- GLTF Loader NOT needed -->
</head>
<body>
    <div id="loading-screen">Loading AURALIS Experience...</div>
    <div id="vr-container"></div>

    <script>
        // --- Configuration ---
        const TEXT_COLOR = '#FFFFFF';
        const PANEL_COLOR = '#111133'; // Dark blue/purple
        const PANEL_HIGHLIGHT_COLOR = '#222255';
        const PANEL_OPACITY = 0.85;
        const TEXT_SIZE = 0.05;
        const PANEL_WIDTH = 2.5;
        const PANEL_HEIGHT = 1.8; // Default height, images will adjust
        const PANEL_RADIUS = 5;
        const GAZE_TIMEOUT = 50;
        const INTERACTION_SCALE = 1.05;

        // --- Image Assets ---
        // Define paths relative to the HTML file.
        // IMPORTANT: Make sure these files exist in an 'images' subfolder!
        const imagePath_Logo = 'images/logo.jpg';            // Replace with your actual filename if different
        const imagePath_WangMeng = 'images/wang_meng.jpg';  // Replace if different
        const imagePath_YuMiao = 'images/yu_miao.jpg';      // Replace if different
        const imagePath_DJBack = 'images/dj_back.jpg';      // Replace if different
        const imagePath_StageWide = 'images/stage_wide.jpg';// Replace if different
        const imagePath_StageDuoBlue = 'images/stage_duo_blue.jpg';// Replace if different
        const imagePath_StageDuoDark = 'images/stage_duo_dark.jpg';// Replace if different

        // --- Text Content ---
        // Uses the image paths defined above
        const content = [
            { type: 'title', text: "AURALIS" },
            { type: 'image', src: imagePath_Logo, width: 2, height: 2 },
            { type: 'text', text: "Step Into Sound and Light:\nA Journey Beyond Music." },
            { type: 'text', text: "Imagine a space where sound moves like liquid, where music swirls around you, weaving vibration and light. Here, past and future collide, ancient strings resonate against modern frequencies, and visuals pulse in harmony. Welcome to AURALIS!" },
            { type: 'header', text: "The Architects of the Experience" },
            { type: 'text', text: "Wang Meng and Yu Miao dissolve boundaries between past/present, acoustic/digital, East/West. An exploration between the organic and synthetic, tradition and the unknown." },
            { type: 'image', src: imagePath_WangMeng, width: 1, height: 1.2 },
            { type: 'text', text: "• Wang Meng: Visionary audio-visual artist, founder of Atomic Visual Studio, pioneer of stage multimedia. Sculpts light like a painter, breathing life into sound." },
            { type: 'image', src: imagePath_YuMiao, width: 1.5, height: 1 },
            { type: 'text', text: "• Yu Miao: Guzheng virtuoso pushing the ancient zither beyond limits, blending delicate timbre with modern sound design. An emotional current from tradition to the unknown." },
            { type: 'header', text: "A World of Sound, A Canvas of Light" },
            { type: 'image', src: imagePath_StageWide, width: 2, height: 1.1 },
            { type: 'text', text: "Air alive with dazzling visuals extending the sonic experience. Light and movement become instruments, responding to every vibration.\n• Projected visuals morph and evolve, reacting to music.\n• Space transforms as music and light dance, bending perception." },
             { type: 'image', src: imagePath_DJBack, width: 1.8, height: 1 },
            { type: 'text', text: "Manels Favre shapes the experience using SPAT Revolution, freeing sound to move, breathe, and surround you in 3D. Notes appear behind, above, beside you." },
            { type: 'header', text: "A New Way to Experience Music" },
             { type: 'image', src: imagePath_StageDuoBlue, width: 1.8, height: 1.1 },
            { type: 'text', text: "Close your eyes, feel the music flow through you. Open them, you are inside a world where sound and light fuse into a living presence." },
            { type: 'image', src: imagePath_StageDuoDark, width: 1.8, height: 1.1 },
            { type: 'text', text: "A journey into sound, space, and emotion.\nA place where the familiar dissolves.\nA moment that will never happen again." },
            { type: 'cta', text: "Step inside.\nLet yourself be carried away.\n\nComing soon!" }
        ];

        // --- Global Variables ---
        let scene, camera, renderer;
        let INTERSECTED;
        let raycaster;
        let vrButton;
        let loadingManager;
        let contentGroup;
        let interactiveObjects = [];
        let clock;
        // No 3D model variables

        // --- Initialization ---
        function init() {
            clock = new THREE.Clock();
            setupLoadingManager();

            scene = new THREE.Scene();
            setupBackground();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('vr-container').appendChild(renderer.domElement);

            vrButton = VRButton.createButton(renderer);
            document.body.appendChild(vrButton);

            const ambientLight = new THREE.AmbientLight(0xCCCCCC, 0.4);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            raycaster = new THREE.Raycaster();
            contentGroup = new THREE.Group();
            scene.add(contentGroup);

            loadAssets(); // Load images from files

            window.addEventListener('resize', onWindowResize, false);
            renderer.setAnimationLoop(render);
        }

        // --- Loading ---
        function setupLoadingManager() {
            loadingManager = new THREE.LoadingManager();
            const loadingScreen = document.getElementById('loading-screen');

            loadingManager.onLoad = function () {
                console.log('Loading complete!');
                loadingScreen.classList.add('fade-out');
                arrangeContent(); // Arrange content after all images are loaded
            };

            loadingManager.onError = function (url) {
                console.error('Error loading asset: ' + url);
                loadingScreen.textContent = `Error loading ${url}. Please check file paths and refresh.`;
            };
            loadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
                console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                loadingScreen.textContent = `Loading: ${itemsLoaded} / ${itemsTotal}`;
            };
        }

        // --- Asset Loading ---
        function loadAssets() {
            const textureLoader = new THREE.TextureLoader(loadingManager); // Pass manager here
            console.log("Starting asset loading...");
            content.forEach(item => {
                if (item.type === 'image') {
                    try {
                        if (typeof item.src === 'string' && item.src) {
                            console.log("Requesting load for:", item.src);
                            item.texture = textureLoader.load(
                                item.src,
                                // Optional: onLoad callback for individual texture
                                function(texture) {
                                    console.log("Successfully loaded:", item.src);
                                    texture.encoding = THREE.sRGBEncoding;
                                },
                                // Optional: onProgress callback (usually not needed per texture)
                                undefined,
                                // Optional: onError callback for individual texture
                                function(err) {
                                    console.error("Error loading texture:", item.src, err);
                                    // You could potentially set a fallback texture here:
                                    // item.texture = fallbackTexture;
                                }
                            );
                            // item.texture.encoding = THREE.sRGBEncoding; // Set encoding immediately or in onLoad
                        } else {
                            console.warn("Invalid or empty image source:", item.src);
                        }
                    } catch (e) {
                        console.error("Error initiating load for image:", item.src, e);
                    }
                }
            });

             // Check if any textures were actually queued with the manager
             // If content array was empty or had no images, onLoad might not fire
             // A simple check (might need refinement for complex cases):
             let imageItems = content.filter(item => item.type === 'image' && typeof item.src === 'string' && item.src);
             if (imageItems.length === 0) {
                 console.log("No image assets to load, proceeding.");
                  // Manually trigger the load complete actions if nothing was loaded
                 setTimeout(() => { // Use timeout to ensure manager setup is complete
                    if (!loadingManager.isLoading) { // Check if manager didn't start loading anything
                        loadingManager.onLoad();
                    }
                 }, 0);
             } else {
                 console.log(`Loading ${imageItems.length} image assets...`);
             }
        }


        // --- Scene Setup ---
        function setupBackground() {
            // Procedural Shader Background (Starry Nebula)
            const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
            const fragmentShader = `varying vec2 vUv; uniform float time; float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123); } float noise(vec2 st) { vec2 i = floor(st); vec2 f = fract(st); float a = random(i); float b = random(i + vec2(1.0, 0.0)); float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; } float fbm(vec2 st) { float value = 0.0; float amplitude = 0.5; for (int i = 0; i < 6; i++) { value += amplitude * noise(st); st *= 2.0; amplitude *= 0.5; } return value; } void main() { vec2 st = vUv * vec2(4.0, 2.0); vec3 color = vec3(0.01, 0.01, 0.05); float n = fbm(st + vec2(time * 0.05, time * 0.02)); color += vec3(n * 0.2, n * 0.1, n * 0.3); float starDensity = 0.995; float starValue = random(vUv * 1000.0 + sin(time*0.1)); if (starValue > starDensity) { float sparkle = sin(time * 5.0 + vUv.x * 100.0) * 0.5 + 0.5; color += vec3(smoothstep(starDensity, 1.0, starValue)) * (0.8 + sparkle * 0.4); } gl_FragColor = vec4(color, 1.0); }`;
            const bgGeometry = new THREE.SphereGeometry(500, 60, 40);
            bgGeometry.scale(-1, 1, 1);
            const bgMaterial = new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms: { time: { value: 0.0 } }, side: THREE.BackSide });
            const backgroundSphere = new THREE.Mesh(bgGeometry, bgMaterial);
            scene.add(backgroundSphere);
        }

        // --- Content Creation ---
        function createTextCanvas(text, panelWidthPixels, panelHeightPixels, isHeader = false, isCTA = false) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const resolutionFactor = 3;
            canvas.width = panelWidthPixels * resolutionFactor;
            canvas.height = panelHeightPixels * resolutionFactor;
            context.fillStyle = `rgba(${parseInt(PANEL_COLOR.slice(1, 3), 16)}, ${parseInt(PANEL_COLOR.slice(3, 5), 16)}, ${parseInt(PANEL_COLOR.slice(5, 7), 16)}, ${PANEL_OPACITY})`;
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = TEXT_COLOR;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            let fontSize = TEXT_SIZE * 100 * resolutionFactor;
            if (isHeader) fontSize *= 1.4;
            if (isCTA) fontSize *= 1.2;
            context.font = `bold ${fontSize}px Arial`;
            const lines = text.split('\n');
            const x = canvas.width / 2;
            let y = canvas.height / 2 - (lines.length - 1) * fontSize * 0.6;
            lines.forEach(line => { context.fillText(line, x, y); y += fontSize * 1.2; });
            return canvas;
        }

        function createContentPanel(item, angle, index) {
            let mesh;
            const panelWidthPixels = 512;
            let panelHeight = PANEL_HEIGHT; // Default

            if (item.type === 'text' || item.type === 'header' || item.type === 'cta' || item.type === 'title') {
                 if (item.type === 'title') panelHeight *= 0.5;
                const textCanvas = createTextCanvas(item.text, panelWidthPixels, panelWidthPixels * (panelHeight / PANEL_WIDTH), item.type === 'header', item.type === 'cta');
                const texture = new THREE.CanvasTexture(textCanvas);
                texture.needsUpdate = true;
                const geometry = new THREE.PlaneGeometry(PANEL_WIDTH, panelHeight);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData = { type: 'textPanel', originalColor: new THREE.Color(PANEL_COLOR), isInteractive: true };

            } else if (item.type === 'image') {
                 if (item.texture && item.texture.image) { // Check if texture and its underlying image have loaded
                     // Calculate aspect ratio FROM the loaded image data if possible
                     const imgAspect = item.texture.image.naturalWidth / item.texture.image.naturalHeight;
                     panelHeight = PANEL_WIDTH / imgAspect; // Adjust height based on actual image aspect ratio

                     const geometry = new THREE.PlaneGeometry(PANEL_WIDTH, panelHeight);
                     const material = new THREE.MeshBasicMaterial({ map: item.texture, color: 0xffffff, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
                     mesh = new THREE.Mesh(geometry, material);

                     const bgGeom = new THREE.PlaneGeometry(PANEL_WIDTH * 1.05, panelHeight * 1.05);
                     const bgMat = new THREE.MeshBasicMaterial({ color: new THREE.Color(PANEL_COLOR), transparent: true, opacity: PANEL_OPACITY, side: THREE.DoubleSide });
                     const bgMesh = new THREE.Mesh(bgGeom, bgMat);
                     bgMesh.position.z = -0.01;
                     mesh.add(bgMesh);
                     mesh.userData = { type: 'imagePanel', originalScale: mesh.scale.clone(), isInteractive: true };
                 } else {
                     console.warn("Skipping panel for image - texture not ready:", item.src);
                     // Optionally create a placeholder panel
                     // const geometry = new THREE.PlaneGeometry(PANEL_WIDTH, PANEL_HEIGHT);
                     // const material = new THREE.MeshBasicMaterial({ color: 0x555555, side: THREE.DoubleSide });
                     // mesh = new THREE.Mesh(geometry, material);
                     // mesh.userData = { type: 'placeholderPanel', isInteractive: false };
                 }
            }


            if (mesh) {
                const x = Math.sin(angle) * PANEL_RADIUS;
                const z = Math.cos(angle) * PANEL_RADIUS;
                 // Slightly stagger vertical position for visual interest
                const y = 1.6 + Math.sin(angle * 2 + index * 0.5) * 0.3; // Base height + variation

                mesh.position.set(x, y, z);
                mesh.lookAt(camera.position);
                contentGroup.add(mesh);
                if (mesh.userData.isInteractive) { // Only add interactive panels to the list
                     interactiveObjects.push(mesh);
                 }
            }
        }

        function arrangeContent() {
            // Clear previous content if re-arranging
            interactiveObjects = [];
            while(contentGroup.children.length > 0){
                contentGroup.remove(contentGroup.children[0]);
            }

            const totalItems = content.length;
            if (totalItems === 0) return;
            const angleSpread = Math.PI * 1.9; // Spread over slightly more than a semi-circle
            const angleStep = angleSpread / totalItems;
            let currentAngle = - (angleSpread / 2); // Start from the left

            console.log("Arranging content panels...");
            content.forEach((item, index) => {
                 createContentPanel(item, currentAngle, index);
                 currentAngle += angleStep;
            });
             console.log("Content arrangement complete. Interactive objects:", interactiveObjects.length);
        }


        // --- Interaction ---
        function handleInteractions() {
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            raycaster.set(camera.position, cameraDirection);
            const intersects = raycaster.intersectObjects(interactiveObjects, true);

            let hitObject = null;
            if (intersects.length > 0) {
                 let firstIntersect = intersects[0].object;
                 while (firstIntersect.parent && firstIntersect.parent !== contentGroup) {
                      if (firstIntersect.userData && firstIntersect.userData.isInteractive) break;
                     firstIntersect = firstIntersect.parent;
                 }
                  if (firstIntersect.userData && firstIntersect.userData.isInteractive) {
                     hitObject = firstIntersect;
                 }
            }

            if (hitObject && INTERSECTED != hitObject) {
                 if (INTERSECTED) { // Reset previous
                     if (INTERSECTED.userData.originalScale) INTERSECTED.scale.copy(INTERSECTED.userData.originalScale);
                     else INTERSECTED.scale.set(1, 1, 1);
                 }
                 INTERSECTED = hitObject; // Set new
                 if (INTERSECTED.userData.originalScale) INTERSECTED.scale.copy(INTERSECTED.userData.originalScale).multiplyScalar(INTERACTION_SCALE);
                 else INTERSECTED.scale.set(INTERACTION_SCALE, INTERACTION_SCALE, INTERACTION_SCALE);

            } else if (!hitObject && INTERSECTED) { // Gaze left
                 if (INTERSECTED.userData.originalScale) INTERSECTED.scale.copy(INTERSECTED.userData.originalScale);
                 else INTERSECTED.scale.set(1, 1, 1);
                 INTERSECTED = null;
            }
        }

        // --- Animation & Rendering ---
        function animateBackground(deltaTime) {
            const bg = scene.children.find(obj => obj.material && obj.material.type === 'ShaderMaterial');
            if (bg) {
                bg.material.uniforms.time.value = clock.getElapsedTime();
            }
        }

        function render() {
            const deltaTime = clock.getDelta();
            handleInteractions();
            animateBackground(deltaTime);
            renderer.render(scene, camera);
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start ---
        init();

    </script>
</body>
</html>