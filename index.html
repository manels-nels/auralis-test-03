<!DOCTYPE html>
<html>
<head>
    <title>AURALIS AR Experience (vFinal Attempt)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="AURALIS AR Experience with robust loading and texture handling.">
    <!-- Scripts A-Frame / AR.js -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; }
        .arjs-loader { height: 100%; width: 100%; position: absolute; top: 0; left: 0; background-color: rgba(0, 0, 0, 0.8); z-index: 9999; display: flex; justify-content: center; align-items: center; flex-direction: column; opacity: 1; transition: opacity 0.5s ease-out; }
        .arjs-loader-message { text-align: center; font-size: 1.25em; color: white; margin-bottom: 15px; }
        #progress-counter { text-align: center; font-size: 1em; color: #ccc; }
        #wechat-notice { position: absolute; top: 10px; left: 10px; right: 10px; padding: 10px; background: rgba(0,0,0,0.7); color: white; z-index: 101; font-size: 14px; text-align: center; border-radius: 5px; }
    </style>
</head>
<body style='margin : 0px; overflow: hidden;'>
    <!-- WeChat Notice -->
    <div id="wechat-notice" onclick="this.style.display='none';">...</div>

    <!-- Loader -->
    <div class="arjs-loader" id="arjs-loader-div">
        <div class="arjs-loader-message">Chargement AURALIS Experience...</div>
        <div id="progress-counter">0/9</div>
    </div>

    <!-- Scène A-Frame AR -->
    <a-scene
        id="ar-scene"
        embedded
        <!-- ** CORRECTION AR.js : Assurer que seul sourceType et debugUIEnabled sont là ** -->
        arjs='sourceType: webcam; debugUIEnabled: false;'
        renderer='logarithmicDepthBuffer: true; colorManagement: true;'
        vr-mode-ui='enabled: false'>

        <!-- Assets -->
        <a-assets timeout="120000">
            <img id="logoImg" src="images/logo.jpg" crossOrigin="anonymous">
            <img id="wangMengImg" src="images/wang_meng.jpg" crossOrigin="anonymous">
            <img id="yuMiaoImg" src="images/yu_miao.jpg" crossOrigin="anonymous">
            <img id="djBackImg" src="images/dj_back.jpg" crossOrigin="anonymous">
            <img id="stageWideImg" src="images/stage_wide.jpg" crossOrigin="anonymous">
            <img id="stageDuoBlueImg" src="images/stage_duo_blue.jpg" crossOrigin="anonymous">
            <img id="stageDuoDarkImg" src="images/stage_duo_dark.jpg" crossOrigin="anonymous">
            <audio id="logoSound" src="audio/your_sound.mp3" preload="auto" crossOrigin="anonymous"></audio>
            <a-asset-item id="jellyfishModel" src="models/meduse.glb" crossOrigin="anonymous"></a-asset-item>
        </a-assets>

        <!-- Contenu -->
        <a-entity id="content-container" position="0 1.5 -4.0" rotation="0 0 0" scale="1 1 1"></a-entity>
        <a-gltf-model id="jellyfish" src="#jellyfishModel" position="-1 2 -2" scale="0.3 0.3 0.3" rotation="0 0 0"
                      animation__pos="property: position; from: -1 2 -2; to: 1 1.2 -1.5; dir: alternate; dur: 12000; easing: easeInOutSine; loop: true;"
                      animation__rot="property: rotation; to: 0 360 0; dur: 20000; easing: linear; loop: true;"
                      animation-mixer="clip: *; loop: repeat"></a-gltf-model>
        <a-camera cursor="rayOrigin: mouse; fuse: false;" raycaster="objects: [data-interactive]"></a-camera>
    </a-scene>

    <!-- Script -->
    <script>
        // --- Configuration ---
        const PANEL_BASE_WIDTH = 1.8; const PANEL_COLOR = '#1a1a3a'; const PANEL_OPACITY = 0.85;
        const BG_Z_OFFSET = -0.01; const IMAGE_Z_OFFSET = 0;
        const imagePositions = {
             'logoImg':         { x: 0,    y: 0,    z: 0.1 }, 'wangMengImg':     { x: -2.2, y: 2,  z: -0.1 },
             'yuMiaoImg':       { x: 2.2,  y: 0.4,  z: -0.1 }, 'stageWideImg':    { x: 0,    y: 2,  z: -0.3 },
             'djBackImg':       { x: 0,    y: -2, z: -0.2 }, 'stageDuoBlueImg': { x: -2.5, y: -0.8, z: 0.2 },
             'stageDuoDarkImg': { x: 2.5,  y: -0.8, z: 0.2 },
        };
        const contentData = [
             { type: 'image', srcId: 'logoImg', originalWidth: 2, originalHeight: 2 }, { type: 'image', srcId: 'wangMengImg', originalWidth: 1, originalHeight: 1.2 },
             { type: 'image', srcId: 'yuMiaoImg', originalWidth: 1.5, originalHeight: 1 }, { type: 'image', srcId: 'stageWideImg', originalWidth: 2, originalHeight: 1.1 },
             { type: 'image', srcId: 'djBackImg', originalWidth: 1, originalHeight: 1.25 }, { type: 'image', srcId: 'stageDuoBlueImg', originalWidth: 1.8, originalHeight: 1.1 },
             { type: 'image', srcId: 'stageDuoDarkImg', originalWidth: 1.8, originalHeight: 1.1 }
        ];

        // --- Variables Globales Loader ---
        const TOTAL_ASSET_COUNT_TARGET = 9;
        const loadedAssetIdsRegistry = new Set();
        let loaderIsHidden = false;
        let sceneIsLoaded = false; // Important pour synchroniser

        // Références DOM
        const progressCounterElement = document.getElementById('progress-counter');
        const loaderDivElement = document.getElementById('arjs-loader-div');
        const sceneElement = document.querySelector('a-scene');
        const assetsElement = document.querySelector('a-assets');

        // --- Fonctions Loader ---
        function hideLoaderAfterCompletion() {
             if (loaderIsHidden) return;
             loaderIsHidden = true;
             console.log(`All ${TOTAL_ASSET_COUNT_TARGET} assets reported. Hiding loader.`);
             progressCounterElement.textContent = `${TOTAL_ASSET_COUNT_TARGET}/${TOTAL_ASSET_COUNT_TARGET}`;
             setTimeout(() => {
                 loaderDivElement.style.opacity = '0';
                 setTimeout(() => { loaderDivElement.style.display = 'none'; }, 500); // Correspond à la transition CSS
             }, 300); // Court délai pour voir 9/9
         }

        function registerAssetLoad(assetId) {
             if (loaderIsHidden || loadedAssetIdsRegistry.has(assetId)) return; // Ne pas traiter si déjà caché ou compté

             loadedAssetIdsRegistry.add(assetId);
             const currentCount = loadedAssetIdsRegistry.size;
             console.log(`Asset loaded/reported: ${assetId} (${currentCount}/${TOTAL_ASSET_COUNT_TARGET})`);
             progressCounterElement.textContent = `${currentCount}/${TOTAL_ASSET_COUNT_TARGET}`;

             // Cacher seulement si TOUS les assets sont chargés ET la scène est prête
             if (currentCount >= TOTAL_ASSET_COUNT_TARGET && sceneIsLoaded) {
                 hideLoaderAfterCompletion();
             } else if (currentCount >= TOTAL_ASSET_COUNT_TARGET && !sceneIsLoaded) {
                 console.log("All assets reported, waiting for scene 'loaded' event to hide loader...");
             }
         }

        // --- ** AMÉLIORÉ : createImagePanel avec Force Update Texture ** ---
        function createImagePanel(itemData, position) {
            const container = document.getElementById('content-container');
            if (!container || !itemData || !itemData.type !== 'image' || !itemData.srcId) return null;

            const imgElement = document.getElementById(itemData.srcId);
            const originalWidth = itemData.originalWidth || imgElement?.naturalWidth || 1;
            const originalHeight = itemData.originalHeight || imgElement?.naturalHeight || 1;

            if (!imgElement) { console.warn(`Image element #${itemData.srcId} not found during panel creation.`); }

            const entity = document.createElement('a-entity');
            const aspect = originalWidth / originalHeight;
            const panelWidth = PANEL_BASE_WIDTH;
            const panelHeight = panelWidth / aspect;

            // Set attributes before appending
            entity.setAttribute('animation__scaleup', `property: scale; to: 1.1 1.1 1.1; startEvents: mouseenter; dur: 200; easing: easeOutQuad;`);
            entity.setAttribute('animation__scaledown', `property: scale; to: 1 1 1; startEvents: mouseleave; dur: 200; easing: easeInQuad;`);
            entity.setAttribute('data-interactive', '');
            entity.setAttribute('position', `${position.x} ${position.y} ${position.z}`); // Positionner avant d'ajouter

            const imgBgPlane = document.createElement('a-plane');
            imgBgPlane.setAttribute('width', panelWidth * 1.05); imgBgPlane.setAttribute('height', panelHeight * 1.05);
            imgBgPlane.setAttribute('material', `color: ${PANEL_COLOR}; opacity: ${PANEL_OPACITY}; shader: flat;`);
            imgBgPlane.setAttribute('position', `0 0 ${BG_Z_OFFSET - 0.005}`);
            entity.appendChild(imgBgPlane);

            const imgPlane = document.createElement('a-plane');
            imgPlane.setAttribute('width', panelWidth); imgPlane.setAttribute('height', panelHeight);
            // Appliquer le matériel AVANT d'ajouter à l'entité peut parfois aider
            imgPlane.setAttribute('material', `src: #${itemData.srcId}; shader: flat; transparent: true;`);
            imgPlane.setAttribute('position', `0 0 ${IMAGE_Z_OFFSET}`);
            entity.appendChild(imgPlane);

            // Forcer la mise à jour de la texture si l'image était déjà chargée
            if (imgElement && imgElement.complete) {
                 // Utiliser un micro-délai pour laisser A-Frame initialiser le composant
                 setTimeout(() => {
                    // Vérifier si l'entité est toujours dans la scène et si le composant existe
                     if (entity.parentNode && imgPlane.components.material) {
                         const material = imgPlane.components.material.material;
                         // Vérifier si la texture (map) existe sur le matériel
                         if (material && material.map) {
                             console.log(` -> Forcing texture update for already complete image: ${itemData.srcId}`);
                             material.map.needsUpdate = true;
                         } else {
                             console.warn(` -> Texture map not ready for update on ${itemData.srcId} after initial delay. May appear blank.`);
                             // On pourrait ajouter une autre tentative avec un délai plus long si nécessaire
                         }
                     }
                 }, 0); // Délai minimum
            }

            if (itemData.srcId === 'logoImg') {
                entity.setAttribute('sound', { src: '#logoSound', autoplay: true, loop: true, volume: 0.8, positional: true, distanceModel: 'inverse', refDistance: 1, rolloffFactor: 1 });
            }

            // Ajouter l'entité complète au conteneur
            container.appendChild(entity);
            return entity;
        }


        // --- Fonction setupManualLayout (Inchangée) ---
        function setupManualLayout() {
             console.log("Setting up manual layout...");
             const container = document.getElementById('content-container');
             if (!container) { console.error("Could not find #content-container entity."); return; }
             while (container.firstChild) { container.removeChild(container.firstChild); }

             contentData.forEach(item => {
                 if (item.type === 'image' && item.srcId && imagePositions[item.srcId]) {
                     createImagePanel(item, imagePositions[item.srcId]); // La création inclut maintenant le force update
                 } else if (item.type === 'image' && item.srcId) {
                     console.warn(`Position not defined for ${item.srcId}.`);
                 }
             });
             console.log("Manual image layout setup finished.");
             sceneIsLoaded = true; // Marquer que la scène ET le layout sont prêts ici
         }


        // --- Logique d'écouteurs et d'initialisation ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Attaching asset listeners...");

            // Fonction pour attacher un listener ou enregistrer immédiatement si l'asset est prêt
            const setupAssetListener = (element, eventName, assetId, checkCondition) => {
                if (!element) {
                    console.warn(`Asset element not found: ${assetId}. Counting as error.`);
                    registerAssetLoad(assetId + '_error');
                    return;
                }
                if (checkCondition()) { // Si déjà prêt (e.g., img.complete, audio.readyState)
                    registerAssetLoad(assetId);
                } else {
                    element.addEventListener(eventName, () => registerAssetLoad(assetId), { once: true });
                    // Ajouter un listener d'erreur générique
                    element.addEventListener('error', () => {
                         console.error(`Failed to load asset: ${assetId}`);
                         registerAssetLoad(assetId + '_error'); // Compter l'erreur pour ne pas bloquer
                    }, { once: true });
                }
            };

            // Images
            const imageIds = ['logoImg', 'wangMengImg', 'yuMiaoImg', 'djBackImg', 'stageWideImg', 'stageDuoBlueImg', 'stageDuoDarkImg'];
            imageIds.forEach(id => {
                setupAssetListener(document.getElementById(id), 'load', id, (el) => el.complete);
            });

            // Audio
            const audioId = 'logoSound';
            setupAssetListener(document.getElementById(audioId), 'canplaythrough', audioId, (el) => el.readyState >= 4);

            // Modèle GLTF (via l'entité)
            const modelEntityId = 'jellyfish';
            let modelListenerAttached = false;
            function attachModelListener() {
                if (modelListenerAttached) return;
                const modelEntity = document.getElementById(modelEntityId);
                if (modelEntity) {
                     console.log(`Attempting to attach 'model-loaded' listener to #${modelEntityId}`);
                      // Vérifier si le modèle n'est pas DÉJÀ chargé
                     if (modelEntity.getObject3D('mesh')) {
                         console.log(`Model ${modelEntityId} already loaded, registering.`);
                         registerAssetLoad(modelEntityId);
                     } else {
                         modelEntity.addEventListener('model-loaded', () => registerAssetLoad(modelEntityId), { once: true });
                     }
                     modelListenerAttached = true;
                } else {
                     // Ne pas logguer d'erreur ici, car on réessaie dans scene.loaded
                     console.warn(`attachModelListener: Entity #${modelEntityId} not found yet. Will retry on scene load.`);
                }
            }
            // Essayer d'attacher tôt (peut échouer, c'est normal)
            setTimeout(attachModelListener, 150);


             // Timeout Global
             let timeoutHasOccurred = false;
             assetsElement?.addEventListener('timeout', () => {
                 if (timeoutHasOccurred || loaderIsHidden) return;
                 timeoutHasOccurred = true;
                 console.error(`!!!!! Assets loading timed out !!!!!`);
                 progressCounterElement.textContent = `Timeout (${loadedAssetIdsRegistry.size}/${TOTAL_ASSET_COUNT_TARGET})`;
                  if (!loaderIsHidden && loadedAssetIdsRegistry.size < TOTAL_ASSET_COUNT_TARGET) {
                       console.warn("Hiding loader after timeout despite missing assets...");
                       setTimeout(hideLoaderAfterCompletion, 1000);
                  }
             }, { once: true });


             // Scene Loaded: Marqueur final et déclencheur pour le layout/listener modèle
             sceneElement.addEventListener('loaded', () => {
                 console.log(">>> Scene 'loaded' event fired.");
                 if (sceneIsLoaded) return; // Déjà traité par hasLoaded ?

                 // Appeler setupManualLayout() QUI mettra sceneIsLoaded à true à la fin
                 setupManualLayout();
                 attachModelListener(); // Dernière chance d'attacher

                 // Si tous les assets étaient déjà chargés avant même scene.loaded
                 if (loadedAssetIdsRegistry.size >= TOTAL_ASSET_COUNT_TARGET && !loaderIsHidden) {
                     console.log("All assets reported loaded before scene fully loaded, hiding loader now.");
                     hideLoaderAfterCompletion();
                 }
             });

             // Gérer si scène déjà chargée (avant que l'écouteur 'loaded' ne soit ajouté)
             if (sceneElement.hasLoaded) {
                 console.log("Scene was already loaded on DOMContentLoaded.");
                 if (!sceneIsLoaded) { // Évite double exécution si 'loaded' se déclenche aussi
                      setupManualLayout(); // Appel direct + met sceneIsLoaded à true
                      attachModelListener();
                      if (loadedAssetIdsRegistry.size >= TOTAL_ASSET_COUNT_TARGET && !loaderIsHidden) {
                           console.log("All assets loaded & scene already loaded, hiding loader now.");
                           hideLoaderAfterCompletion();
                      }
                 }
             }
        });

    </script>
</body>
</html>
