<!DOCTYPE html>
<html>
<head>
    <title>AURALIS AR Experience (Force Texture Update)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="AURALIS AR Experience with forced texture update for pre-loaded images.">
    <!-- Scripts A-Frame / AR.js -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.min.js"></script>

    <style>
        /* Styles inchangés */
        body { margin: 0; overflow: hidden; }
        #wechat-notice { /* ... */ }
        .arjs-loader { /* ... */ }
        .arjs-loader-message { /* ... */ }
        #progress-text { /* ... */ }
        #progress-text.error { /* ... */ }
    </style>
</head>
<body style='margin : 0px; overflow: hidden;'>
    <!-- WeChat Notice -->
    <div id="wechat-notice" onclick="this.style.display='none';">...</div>

    <!-- Loader -->
    <div class="arjs-loader" id="arjs-loader-div">
        <div class="arjs-loader-message">Chargement des éléments AURALIS...</div>
        <div id="progress-text">0/9</div>
    </div>

    <!-- Scène A-Frame -->
    <a-scene id="ar-scene" embedded arjs='...' renderer='...' vr-mode-ui='enabled: false'>

        <!-- Assets -->
        <a-assets timeout="120000">
             <img id="logoImg" src="images/logo.jpg" crossOrigin="anonymous">
             <img id="wangMengImg" src="images/wang_meng.jpg" crossOrigin="anonymous">
             <img id="yuMiaoImg" src="images/yu_miao.jpg" crossOrigin="anonymous">
             <img id="djBackImg" src="images/dj_back.jpg" crossOrigin="anonymous">
             <img id="stageWideImg" src="images/stage_wide.jpg" crossOrigin="anonymous">
             <img id="stageDuoBlueImg" src="images/stage_duo_blue.jpg" crossOrigin="anonymous">
             <img id="stageDuoDarkImg" src="images/stage_duo_dark.jpg" crossOrigin="anonymous">
             <audio id="logoSound" src="audio/your_sound.mp3" preload="auto" crossOrigin="anonymous"></audio>
             <a-asset-item id="jellyfishModelAsset" src="models/meduse.glb" crossOrigin="anonymous"></a-asset-item>
        </a-assets>

        <!-- Contenu -->
        <a-entity id="content-container" position="0 1.5 -4.0" rotation="0 0 0" scale="1 1 1"></a-entity>
        <a-gltf-model id="jellyfish-entity" src="#jellyfishModelAsset" position="..." scale="..." rotation="..."
                      animation__pos="..." animation__rot="..." animation-mixer="..."></a-gltf-model>
        <a-camera cursor="..." raycaster="..."></a-camera>
    </a-scene>

    <!-- Script -->
    <script>
        // --- Config (inchangée) ---
        const PANEL_BASE_WIDTH = 1.8; const PANEL_COLOR = '#1a1a3a'; const PANEL_OPACITY = 0.85;
        const BG_Z_OFFSET = -0.01; const IMAGE_Z_OFFSET = 0;
        const imagePositions = { /* ... */ }; const contentData = [ /* ... */ ];

        // --- Variables Globales pour le chargement ---
        const TOTAL_ASSET_COUNT = 9;
        let loadedAssetCount = 0;
        let loaderHidden = false;
        let layoutReady = false;
        // Garder une trace simple de quels assets ont fini leur événement 'load'/'canplaythrough'/'loaded'
        const assetLoadCompleted = {};

        // --- Fonctions ---

        // Met à jour le compteur et cache le loader si tout est prêt
        function updateLoaderProgress(assetId) {
            if (loaderHidden || !assetLoadCompleted[assetId]) return; // Si déjà caché ou si l'asset n'est pas marqué comme chargé

             // Vérifier que cet asset n'a pas déjà été compté
            if (assetLoadCompleted[assetId] !== 'counted') {
                loadedAssetCount++;
                assetLoadCompleted[assetId] = 'counted'; // Marquer comme compté
                console.log(`Loader Count: ${loadedAssetCount}/${TOTAL_ASSET_COUNT} (counted ${assetId})`);
                progressText.textContent = `${loadedAssetCount}/${TOTAL_ASSET_COUNT}`;

                if (loadedAssetCount >= TOTAL_ASSET_COUNT) {
                    hideLoader();
                }
            }
        }

        function hideLoader() {
            if (loaderHidden) return;
            loaderHidden = true;
            console.log('All assets counted. Hiding loader...');
            const hideDelay = 100; // Court délai final
            setTimeout(() => {
                loaderDiv.style.opacity = '0';
                setTimeout(() => { loaderDiv.style.display = 'none'; }, 500);
            }, hideDelay);
        }

        // *** MODIFIÉ : createImagePanel ***
        function createImagePanel(itemData, position) {
            const container = document.getElementById('content-container');
            if (!container || !itemData || itemData.type !== 'image' || !itemData.srcId) return null;

            const imgElement = document.getElementById(itemData.srcId);
            const originalWidth = itemData.originalWidth || imgElement?.naturalWidth;
            const originalHeight = itemData.originalHeight || imgElement?.naturalHeight;

            const entity = document.createElement('a-entity');
            const aspect = (originalWidth && originalHeight) ? originalWidth / originalHeight : 1;
            const panelWidth = PANEL_BASE_WIDTH;
            const panelHeight = aspect ? panelWidth / aspect : PANEL_BASE_WIDTH;

            // ... (animations, data-interactive, fond - inchangés) ...
            entity.setAttribute('animation__scaleup', `property: scale; to: 1.1 1.1 1.1; startEvents: mouseenter; dur: 200; easing: easeOutQuad;`);
            entity.setAttribute('animation__scaledown', `property: scale; to: 1 1 1; startEvents: mouseleave; dur: 200; easing: easeInQuad;`);
            entity.setAttribute('data-interactive', '');
            const imgBgPlane = document.createElement('a-plane');
            imgBgPlane.setAttribute('width', panelWidth * 1.05); imgBgPlane.setAttribute('height', panelHeight * 1.05);
            imgBgPlane.setAttribute('material', `color: ${PANEL_COLOR}; opacity: ${PANEL_OPACITY}; shader: flat;`);
            imgBgPlane.setAttribute('position', `0 0 ${BG_Z_OFFSET - 0.005}`);
            entity.appendChild(imgBgPlane);

            const imgPlane = document.createElement('a-plane'); // Image plane
            imgPlane.setAttribute('width', panelWidth);
            imgPlane.setAttribute('height', panelHeight);
            imgPlane.setAttribute('material', `src: #${itemData.srcId}; shader: flat; transparent: true;`);
            imgPlane.setAttribute('position', `0 0 ${IMAGE_Z_OFFSET}`);
            entity.appendChild(imgPlane);

            // **** DEBUT : Forcer la mise à jour de la texture ****
            // Vérifier si l'image correspondante était déjà marquée comme chargée
            // Mettre dans un setTimeout pour laisser A-Frame initialiser le material component
            setTimeout(() => {
                if (assetLoadCompleted[itemData.srcId] && imgPlane.components.material) {
                    const material = imgPlane.components.material.material;
                    if (material.map) {
                         console.log(`Forcing texture update for pre-loaded image: ${itemData.srcId}`);
                         material.map.needsUpdate = true;
                    } else {
                         // Parfois, la map n'est pas prête immédiatement même après setTimeout(0)
                         // On pourrait essayer de re-vérifier après un délai plus long si nécessaire
                         console.warn(`Material map not ready for texture update on ${itemData.srcId}, trying again shortly...`);
                         setTimeout(() => {
                              if (material.map) {
                                   console.log(`Retrying texture update for ${itemData.srcId}`);
                                   material.map.needsUpdate = true;
                              } else {
                                   console.error(`Still no material map for ${itemData.srcId} after second delay.`);
                              }
                         }, 200); // Délai supplémentaire
                    }
                 }
             }, 0); // Délai minimum pour passer au prochain tick de l'event loop
             // **** FIN : Forcer la mise à jour de la texture ****


            if (itemData.srcId === 'logoImg') { // Son
                entity.setAttribute('sound', { src: '#logoSound', autoplay: true, loop: true, volume: 0.8, positional: true, distanceModel: 'inverse', refDistance: 1, rolloffFactor: 1 });
                console.log(`Attempting to add sound component to logoImg panel.`);
            }

            entity.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
            container.appendChild(entity);
            return entity;
        }

        function setupManualLayout() {
            console.log("Setting up manual layout...");
            const container = document.getElementById('content-container');
            if (!container) { console.error("Content container not found."); return; }
            while (container.firstChild) { container.removeChild(container.firstChild); }

            contentData.forEach(item => {
                if (item.type === 'image' && item.srcId && imagePositions[item.srcId]) {
                    createImagePanel(item, imagePositions[item.srcId]);
                } else if (item.type === 'image') {
                    console.warn(`Position non définie pour ${item.srcId}.`);
                }
            });
            console.log("Manual image layout setup finished.");
            layoutReady = true; // Marquer comme prêt APRÈS la création des éléments
        }

        // --- LOGIQUE DE CHARGEMENT PRINCIPALE ---
        document.addEventListener('DOMContentLoaded', () => {
            const progressText = document.getElementById('progress-text');
            const loaderDiv = document.getElementById('arjs-loader-div');
            const sceneEl = document.querySelector('a-scene');
            const assetsEl = document.querySelector('a-assets');

            // Initialiser le statut de chargement
            const imageIds = ['logoImg', 'wangMengImg', 'yuMiaoImg', 'djBackImg', 'stageWideImg', 'stageDuoBlueImg', 'stageDuoDarkImg'];
            const audioId = 'logoSound';
            const modelAssetItemId = 'jellyfishModelAsset';
            const allAssetIds = [...imageIds, audioId, modelAssetItemId];
            allAssetIds.forEach(id => assetLoadCompleted[id] = false); // Initialiser à non chargé

            // --- Écouteurs ---

            // Images
            imageIds.forEach(id => {
                const img = document.getElementById(id);
                if (img) {
                    const handleImageLoad = () => {
                        console.log(`Event 'load' received for image: ${id}`);
                        assetLoadCompleted[id] = true; // Marquer comme chargé
                        // Essayer de mettre à jour le compteur seulement si le layout est prêt
                        if (layoutReady) {
                            updateLoaderProgress(id);
                        }
                    };
                    if (img.complete) { // Gérer cache
                         handleImageLoad();
                    } else {
                         img.addEventListener('load', handleImageLoad, { once: true });
                         img.addEventListener('error', () => console.error(`Failed image: ${id}`), { once: true });
                    }
                } else { console.warn(`Image ${id} not found.`); }
            });

            // Audio
            const audio = document.getElementById(audioId);
            if (audio) {
                 const handleAudioLoad = () => {
                      console.log(`Event 'canplaythrough' received for audio: ${audioId}`);
                      assetLoadCompleted[audioId] = true;
                      if (layoutReady) {
                           updateLoaderProgress(audioId);
                      }
                 };
                 if (audio.readyState >= 4) { // Gérer cache/préchargement
                      handleAudioLoad();
                 } else {
                      audio.addEventListener('canplaythrough', handleAudioLoad, { once: true });
                      audio.addEventListener('error', () => console.error(`Failed audio: ${audioId}`), { once: true });
                 }
            } else { console.warn(`Audio ${audioId} not found.`); }

            // Asset Item (Modèle)
             const modelAssetItem = document.getElementById(modelAssetItemId);
             if (modelAssetItem) {
                  const handleModelLoad = () => {
                       console.log(`Event 'loaded' received for asset-item: ${modelAssetItemId}`);
                       assetLoadCompleted[modelAssetItemId] = true;
                       if (layoutReady) {
                            updateLoaderProgress(modelAssetItemId);
                       }
                  };
                  // Vérifier la propriété 'data' peut être moins fiable que l'événement
                  // if (modelAssetItem.data) { handleModelLoad(); } else {
                  modelAssetItem.addEventListener('loaded', handleModelLoad, { once: true });
                  // }
             } else { console.warn(`Asset item ${modelAssetItemId} not found.`); }


            // Timeout global
             let timeoutOccurred = false;
             assetsEl.addEventListener('timeout', () => {
                 if (timeoutOccurred || loaderHidden) return;
                 timeoutOccurred = true;
                 console.error(`!!!!! Assets loading timed out via <a-assets> !!!!!`);
                 progressText.textContent = `Erreur Timeout (${loadedAssetCount}/${TOTAL_ASSET_COUNT})`;
                 progressText.classList.add('error');
             }, { once: true });

            // Scène chargée -> Créer Layout + Rattraper Compteur
             sceneEl.addEventListener('loaded', () => {
                 console.log(">>> Scene 'loaded' event fired.");
                 if (layoutReady) return;

                 setupManualLayout(); // Crée les a-planes etc ET met layoutReady = true

                 console.log("Syncing counter state after layout setup...");
                 // Mettre à jour le compteur pour tous les assets qui ont fini AVANT scene.loaded
                 allAssetIds.forEach(id => {
                     if (assetLoadCompleted[id]) { // Si marqué comme chargé
                         updateLoaderProgress(id); // Tente de mettre à jour le compteur visible
                     }
                 });
             });

            // Gérer si scène déjà chargée
             if (sceneEl.hasLoaded) {
                 console.log("Scene was already loaded on DOMContentLoaded.");
                 if (!layoutReady) {
                     setupManualLayout();
                     console.log("Syncing counter state after layout setup...");
                      allAssetIds.forEach(id => {
                         if (assetLoadCompleted[id]) {
                             updateLoaderProgress(id);
                         }
                     });
                 }
             }
        });
    </script>
</body>
</html>
