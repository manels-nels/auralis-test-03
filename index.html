<!DOCTYPE html>
<html>
<head>
    <title>AURALIS AR Experience (Synced Layout & Asset Count)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="AURALIS AR Experience using A-Frame and AR.js with synced layout and asset item count progress.">
    <!-- A-Frame Core -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <!-- AR.js for A-Frame -->
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.min.js"></script>

    <style>
        /* Styles inchangés */
        body { margin: 0; overflow: hidden; }
        #wechat-notice { position: absolute; top: 10px; left: 10px; right: 10px; padding: 10px; background: rgba(0,0,0,0.7); color: white; z-index: 101; font-size: 14px; text-align: center; border-radius: 5px; }
        .arjs-loader { height: 100%; width: 100%; position: absolute; top: 0; left: 0; background-color: rgba(0, 0, 0, 0.9); z-index: 9999; display: flex; justify-content: center; align-items: center; flex-direction: column; opacity: 1; transition: opacity 0.5s ease-out; }
        .arjs-loader-message { text-align: center; font-size: 1.25em; color: white; margin-bottom: 15px; }
        #progress-text { color: #ccc; font-size: 1em; }
        #progress-text.error { color: #ff6b6b; }
    </style>
</head>
<body style='margin : 0px; overflow: hidden;'>
    <!-- WeChat Notice -->
    <div id="wechat-notice" onclick="this.style.display='none';">...</div>

    <!-- Loader -->
    <div class="arjs-loader" id="arjs-loader-div">
        <div class="arjs-loader-message">Chargement des éléments AURALIS...</div>
        <div id="progress-text">0/9</div>
    </div>

    <!-- Scène A-Frame -->
    <a-scene id="ar-scene" embedded arjs='sourceType: webcam; trackingMethod: best; debugUIEnabled: false;'
        renderer='logarithmicDepthBuffer: true; colorManagement: true;' vr-mode-ui='enabled: false'>

        <!-- Assets -->
        <a-assets timeout="120000">
             <img id="logoImg" src="images/logo.jpg" crossOrigin="anonymous">
             <img id="wangMengImg" src="images/wang_meng.jpg" crossOrigin="anonymous">
             <img id="yuMiaoImg" src="images/yu_miao.jpg" crossOrigin="anonymous">
             <img id="djBackImg" src="images/dj_back.jpg" crossOrigin="anonymous">
             <img id="stageWideImg" src="images/stage_wide.jpg" crossOrigin="anonymous">
             <img id="stageDuoBlueImg" src="images/stage_duo_blue.jpg" crossOrigin="anonymous">
             <img id="stageDuoDarkImg" src="images/stage_duo_dark.jpg" crossOrigin="anonymous">
             <audio id="logoSound" src="audio/your_sound.mp3" preload="auto" crossOrigin="anonymous"></audio>
             <!-- Ajouter un ID à l'asset-item pour le suivre -->
             <a-asset-item id="jellyfishModelAsset" src="models/meduse.glb" crossOrigin="anonymous"></a-asset-item>
        </a-assets>

        <!-- Contenu -->
        <a-entity id="content-container" position="0 1.5 -4.0" rotation="0 0 0" scale="1 1 1"></a-entity>
        <!-- L'ID ici n'est plus utilisé pour le suivi de chargement principal -->
        <a-gltf-model id="jellyfish-entity" src="#jellyfishModelAsset" position="-1 2 -2" scale="0.3 0.3 0.3" rotation="0 0 0"
                      animation__pos="property: position; from: -1 2 -2; to: 1 1.2 -1.5; dir: alternate; dur: 12000; easing: easeInOutSine; loop: true;"
                      animation__rot="property: rotation; to: 0 360 0; dur: 20000; easing: linear; loop: true;"
                      animation-mixer="clip: *; loop: repeat"></a-gltf-model>
        <a-camera cursor="rayOrigin: mouse; fuse: false;" raycaster="objects: [data-interactive]"></a-camera>
    </a-scene>

    <!-- Script -->
    <script>
        // --- Config (inchangée) ---
        const PANEL_BASE_WIDTH = 1.8; const PANEL_COLOR = '#1a1a3a'; const PANEL_OPACITY = 0.85;
        const BG_Z_OFFSET = -0.01; const IMAGE_Z_OFFSET = 0;
        const imagePositions = { /* ... */ }; const contentData = [ /* ... */ ];

        // --- Fonctions create/setup (non montrées pour brièveté, mais importantes) ---
        function createImagePanel(itemData, position) {
            const container = document.getElementById('content-container');
            if (!container || !itemData || itemData.type !== 'image' || !itemData.srcId) return null;
            const imgElement = document.getElementById(itemData.srcId);
            // On peut supposer ici que si setupManualLayout est appelé, les images *devraient* être chargées
            // Mais une vérification naturalWidth/Height reste une bonne pratique
            const originalWidth = itemData.originalWidth || imgElement?.naturalWidth;
            const originalHeight = itemData.originalHeight || imgElement?.naturalHeight;

            // Si l'image n'a pas de dimensions (erreur de chargement?), créer un placeholder ou logguer
             if (!originalWidth || !originalHeight) {
                 console.warn(`Dimensions manquantes pour l'image ${itemData.srcId} lors de la création du panneau.`);
                 // return null; // Option: ne pas créer le panneau si l'image a échoué
             }


            const entity = document.createElement('a-entity');
            const aspect = (originalWidth && originalHeight) ? originalWidth / originalHeight : 1;
            const panelWidth = PANEL_BASE_WIDTH;
            const panelHeight = aspect ? panelWidth / aspect : PANEL_BASE_WIDTH;
            entity.setAttribute('animation__scaleup', `property: scale; to: 1.1 1.1 1.1; startEvents: mouseenter; dur: 200; easing: easeOutQuad;`);
            entity.setAttribute('animation__scaledown', `property: scale; to: 1 1 1; startEvents: mouseleave; dur: 200; easing: easeInQuad;`);
            entity.setAttribute('data-interactive', '');
            const imgBgPlane = document.createElement('a-plane'); // Fond
            imgBgPlane.setAttribute('width', panelWidth * 1.05); imgBgPlane.setAttribute('height', panelHeight * 1.05);
            imgBgPlane.setAttribute('material', `color: ${PANEL_COLOR}; opacity: ${PANEL_OPACITY}; shader: flat;`);
            imgBgPlane.setAttribute('position', `0 0 ${BG_Z_OFFSET - 0.005}`);
            entity.appendChild(imgBgPlane);
            const imgPlane = document.createElement('a-plane'); // Image
            imgPlane.setAttribute('width', panelWidth); imgPlane.setAttribute('height', panelHeight);
            // --- Très important: s'assurer que la texture est bien appliquée ---
            // A-Frame devrait le faire automatiquement, mais on peut forcer une mise à jour si besoin
            imgPlane.setAttribute('material', `src: #${itemData.srcId}; shader: flat; transparent: true;`);
            // Petite astuce pour potentiellement forcer la relecture de la source
            // setTimeout(() => { if (entity.parentNode) imgPlane.components.material.material.map.needsUpdate = true; }, 100);

            entity.appendChild(imgPlane);
            if (itemData.srcId === 'logoImg') { // Son
                entity.setAttribute('sound', { src: '#logoSound', autoplay: true, loop: true, volume: 0.8, positional: true, distanceModel: 'inverse', refDistance: 1, rolloffFactor: 1 });
                console.log(`Attempting to add sound component to logoImg panel.`);
            }
            entity.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
            container.appendChild(entity);
            return entity;
         }
        function setupManualLayout() {
            console.log("Setting up manual layout...");
            const container = document.getElementById('content-container');
            if (!container) { console.error("Could not find #content-container entity."); return; }
            while (container.firstChild) { container.removeChild(container.firstChild); } // Vider
            contentData.forEach(item => {
                if (item.type === 'image' && item.srcId && imagePositions[item.srcId]) {
                    createImagePanel(item, imagePositions[item.srcId]);
                } else if (item.type === 'image' && item.srcId) { console.warn(`Position non définie pour ${item.srcId}.`); }
            });
             console.log("Manual image layout setup finished.");
         }


        // --- LOGIQUE DE CHARGEMENT (Layout Sync + Asset Item Count) ---
        document.addEventListener('DOMContentLoaded', () => {
            const TOTAL_ASSET_COUNT = 9; // 7 images + 1 audio + 1 asset-item (.glb)
            let loadedAssetCount = 0;
            let loaderHidden = false;
            let layoutReady = false; // Flag: Le layout a-t-il été créé ?

            // Pour suivre quels assets ont *terminé* leur chargement (même avant que le layout soit prêt)
            const assetDataLoaded = {};

            const progressText = document.getElementById('progress-text');
            const loaderDiv = document.getElementById('arjs-loader-div');
            const sceneEl = document.querySelector('a-scene');
            const assetsEl = document.querySelector('a-assets');

            // IDs des assets à suivre
            const imageIds = ['logoImg', 'wangMengImg', 'yuMiaoImg', 'djBackImg', 'stageWideImg', 'stageDuoBlueImg', 'stageDuoDarkImg'];
            const audioId = 'logoSound';
            const modelAssetItemId = 'jellyfishModelAsset'; // ID de l'<a-asset-item>

            // --- Fonctions de gestion ---
            function hideLoader() {
                if (loaderHidden) return;
                loaderHidden = true;
                console.log('All assets counted and layout ready. Hiding loader...');
                // Court délai final optionnel
                const hideDelay = 100;
                setTimeout(() => {
                    loaderDiv.style.opacity = '0';
                    setTimeout(() => { loaderDiv.style.display = 'none'; }, 500); // Durée transition CSS
                }, hideDelay);
            }

            function incrementLoader(assetId) {
                 // Ne pas incrémenter si déjà caché ou si cet asset a déjà été compté
                 if (loaderHidden || !assetDataLoaded[assetId]) return;

                 loadedAssetCount++;
                 console.log(`Loader Count: ${loadedAssetCount}/${TOTAL_ASSET_COUNT} (incremented by ${assetId})`);
                 progressText.textContent = `${loadedAssetCount}/${TOTAL_ASSET_COUNT}`;

                 // Marquer comme compté pour l'affichage (au cas où)
                 // assetDataLoaded[assetId] = false; // Optionnel : pour éviter double comptage strict

                 if (loadedAssetCount >= TOTAL_ASSET_COUNT) {
                    hideLoader();
                 }
            }

            // Fonction appelée quand un asset a fini de charger ses *données*
            function markAssetDataLoaded(assetId) {
                if (assetDataLoaded[assetId]) return; // Déjà marqué
                console.log(`Data loaded for: ${assetId}`);
                assetDataLoaded[assetId] = true;

                // Si le layout est déjà prêt, on peut incrémenter le compteur visible immédiatement
                if (layoutReady) {
                    incrementLoader(assetId);
                }
            }

             // --- Écouteurs pour chaque asset ---

             // Images
             imageIds.forEach(id => {
                 assetDataLoaded[id] = false; // Initialiser
                 const img = document.getElementById(id);
                 if (img) {
                     if (img.complete) {
                         markAssetDataLoaded(id);
                     } else {
                         img.addEventListener('load', () => markAssetDataLoaded(id), { once: true });
                         img.addEventListener('error', () => console.error(`Failed image: ${id}`), { once: true });
                     }
                 } else { console.warn(`Image ${id} not found.`); }
             });

             // Audio
             assetDataLoaded[audioId] = false; // Initialiser
             const audio = document.getElementById(audioId);
             if (audio) {
                 if (audio.readyState >= 4) { // HAVE_ENOUGH_DATA
                     markAssetDataLoaded(audioId);
                 } else {
                     audio.addEventListener('canplaythrough', () => markAssetDataLoaded(audioId), { once: true });
                     audio.addEventListener('error', () => console.error(`Failed audio: ${audioId}`), { once: true });
                 }
             } else { console.warn(`Audio ${audioId} not found.`); }

             // Asset Item (Modèle GLB) - On écoute l'élément <a-asset-item>
             assetDataLoaded[modelAssetItemId] = false; // Initialiser
             const modelAssetItem = document.getElementById(modelAssetItemId);
             if (modelAssetItem) {
                  // L'événement 'load' sur a-asset-item est moins documenté, mais devrait fonctionner pour les fichiers binaires.
                  // On vérifie aussi si 'data' est déjà là (chargé par cache/très vite)
                  if (modelAssetItem.data) {
                       markAssetDataLoaded(modelAssetItemId);
                  } else {
                       modelAssetItem.addEventListener('loaded', () => markAssetDataLoaded(modelAssetItemId), { once: true });
                       // Pas d'événement 'error' standard sur a-asset-item, on se fie au timeout
                  }

             } else { console.warn(`Asset item ${modelAssetItemId} not found.`); }


             // --- Filet de Sécurité : Timeout Global ---
             let timeoutOccurred = false;
             assetsEl.addEventListener('timeout', () => {
                 if (timeoutOccurred || loaderHidden) return;
                 timeoutOccurred = true;
                 console.error(`!!!!! Assets loading timed out via <a-assets> !!!!!`);
                 // Afficher l'erreur, mais ne pas changer la classe pour l'instant
                 progressText.textContent = `Erreur Timeout (${loadedAssetCount}/${TOTAL_ASSET_COUNT})`;
             }, { once: true });


             // --- La scène est prête : Créer le layout et rattraper le comptage ---
             sceneEl.addEventListener('loaded', () => {
                 console.log(">>> Scene 'loaded' event fired. Setting up layout and syncing counter.");
                 if (layoutReady) return; // Exécuter une seule fois

                 setupManualLayout();
                 layoutReady = true; // Marquer le layout comme prêt

                 // Maintenant que le layout est prêt, incrémenter pour tous les assets dont les données sont déjà chargées
                 console.log("Syncing loader count for previously loaded asset data...");
                 for (const assetId in assetDataLoaded) {
                     if (assetDataLoaded[assetId]) {
                         incrementLoader(assetId);
                     }
                 }
             });

             // Gérer si scène déjà chargée
             if (sceneEl.hasLoaded) {
                 console.log("Scene was already loaded on DOMContentLoaded.");
                 if (!layoutReady) {
                     setupManualLayout();
                     layoutReady = true;
                     console.log("Syncing loader count for previously loaded asset data...");
                     for (const assetId in assetDataLoaded) {
                         if (assetDataLoaded[assetId]) {
                            incrementLoader(assetId);
                         }
                     }
                 }
             }
        }); // Fin DOMContentLoaded
    </script>
</body>
</html>
