<!DOCTYPE html>
<html lang="en">
<head>
    <title>AURALIS VR Experience</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="AURALIS: Step Into Sound and Light. An immersive VR music and video performance by Wang Meng and Yu Miao.">
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; overflow: hidden; background-color: #000; color: #fff; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #vr-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; display: flex; justify-content: center; align-items: center; font-size: 1.5em; z-index: 100; transition: opacity 1s ease-out; }
        #loading-screen.fade-out { opacity: 0; pointer-events: none; }
        canvas { display: block; }
    </style>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
    <!-- VR Button (Version Spécifique) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/VRButton.js" defer></script>

</head>
<body>
    <div id="loading-screen">Loading AURALIS Experience...</div>
    <div id="vr-container"></div>

    {/* <!-- Le script principal est maintenant ici, juste avant </body> --> */}
    <script>
        // --- Configuration ---
        const TEXT_COLOR = '#FFFFFF';
        const PANEL_COLOR = '#111133';
        const PANEL_OPACITY = 0.85;
        const TEXT_SIZE = 0.05;
        const PANEL_WIDTH = 2.5;
        const PANEL_HEIGHT = 1.8;
        const PANEL_RADIUS = 5;
        const INTERACTION_SCALE = 1.05;

        // --- Image Assets ---
        console.log("Defining image paths..."); // Log: Start defining paths
        const imagePath_Logo = 'images/logo.jpg';
        const imagePath_WangMeng = 'images/wang_meng.jpg';
        const imagePath_YuMiao = 'images/yu_miao.jpg';
        const imagePath_DJBack = 'images/dj_back.jpg';
        const imagePath_StageWide = 'images/stage_wide.jpg';
        const imagePath_StageDuoBlue = 'images/stage_duo_blue.jpg';
        const imagePath_StageDuoDark = 'images/stage_duo_dark.jpg';
        console.log("Image paths defined."); // Log: Paths defined

        // --- Text Content ---
        const content = [
            { type: 'title', text: "AURALIS" },
            { type: 'image', src: imagePath_Logo, width: 2, height: 2 },
            { type: 'text', text: "Step Into Sound and Light:\nA Journey Beyond Music." },
            { type: 'text', text: "Imagine a space where sound moves like liquid, where music swirls around you, weaving vibration and light. Here, past and future collide, ancient strings resonate against modern frequencies, and visuals pulse in harmony. Welcome to AURALIS!" },
            { type: 'header', text: "The Architects of the Experience" },
            { type: 'text', text: "Wang Meng and Yu Miao dissolve boundaries between past/present, acoustic/digital, East/West. An exploration between the organic and synthetic, tradition and the unknown." },
            { type: 'image', src: imagePath_WangMeng, width: 1, height: 1.2 },
            { type: 'text', text: "• Wang Meng: Visionary audio-visual artist, founder of Atomic Visual Studio, pioneer of stage multimedia. Sculpts light like a painter, breathing life into sound." },
            { type: 'image', src: imagePath_YuMiao, width: 1.5, height: 1 },
            { type: 'text', text: "• Yu Miao: Guzheng virtuoso pushing the ancient zither beyond limits, blending delicate timbre with modern sound design. An emotional current from tradition to the unknown." },
            { type: 'header', text: "A World of Sound, A Canvas of Light" },
            { type: 'image', src: imagePath_StageWide, width: 2, height: 1.1 },
            { type: 'text', text: "Air alive with dazzling visuals extending the sonic experience. Light and movement become instruments, responding to every vibration.\n• Projected visuals morph and evolve, reacting to music.\n• Space transforms as music and light dance, bending perception." },
             { type: 'image', src: imagePath_DJBack, width: 1.8, height: 1 },
            { type: 'text', text: "Manels Favre shapes the experience using SPAT Revolution, freeing sound to move, breathe, and surround you in 3D. Notes appear behind, above, beside you." },
            { type: 'header', text: "A New Way to Experience Music" },
             { type: 'image', src: imagePath_StageDuoBlue, width: 1.8, height: 1.1 },
            { type: 'text', text: "Close your eyes, feel the music flow through you. Open them, you are inside a world where sound and light fuse into a living presence." },
            { type: 'image', src: imagePath_StageDuoDark, width: 1.8, height: 1.1 },
            { type: 'text', text: "A journey into sound, space, and emotion.\nA place where the familiar dissolves.\nA moment that will never happen again." },
            { type: 'cta', text: "Step inside.\nLet yourself be carried away.\n\nComing soon!" }
        ];

        // --- Global Variables ---
        let scene, camera, renderer;
        let INTERSECTED;
        let raycaster;
        let vrButton;
        let loadingManager;
        let contentGroup;
        let interactiveObjects = [];
        let clock;

        // --- Initialization ---
        function init() {
            console.log("Initializing scene..."); // Log: Init start
            clock = new THREE.Clock();
            setupLoadingManager(); // Setup manager first

            scene = new THREE.Scene();
            setupBackground();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('vr-container').appendChild(renderer.domElement);

            // CRITICAL: Check if VRButton is now defined *before* using it
            if (typeof VRButton === 'undefined') {
                console.error("VRButton is STILL undefined right before creating the button!");
                // Optionally display an error to the user here
                document.getElementById('loading-screen').textContent = "Error: VR components failed to load.";
                return; // Stop initialization if VRButton is missing
            } else {
                 console.log("VRButton is defined. Creating button..."); // Log: VRButton check OK
                 try {
                    vrButton = VRButton.createButton(renderer);
                    document.body.appendChild(vrButton);
                 } catch (error) {
                     console.error("Error creating VR Button:", error);
                     document.getElementById('loading-screen').textContent = "Error initializing VR button.";
                     return;
                 }
            }


            const ambientLight = new THREE.AmbientLight(0xCCCCCC, 0.4);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            raycaster = new THREE.Raycaster();
            contentGroup = new THREE.Group();
            scene.add(contentGroup);

            loadAssets(); // Start loading assets

            window.addEventListener('resize', onWindowResize, false);
            renderer.setAnimationLoop(render);
            console.log("Initialization complete."); // Log: Init end
        }

        // --- Loading ---
        function setupLoadingManager() {
            console.log("Setting up LoadingManager..."); // Log: Manager setup start
            loadingManager = new THREE.LoadingManager();
            const loadingScreen = document.getElementById('loading-screen');

            loadingManager.onStart = function ( url, itemsLoaded, itemsTotal ) {
                console.log( 'LoadingManager: Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
            };

            loadingManager.onLoad = function () {
                console.log('LoadingManager: Loading complete!'); // Log: Manager onLoad
                // Ensure arrangeContent is defined before calling
                if(typeof arrangeContent === 'function') {
                    arrangeContent(); // Arrange content ONLY when loading is fully complete
                } else {
                     console.error("arrangeContent function not found when onLoad triggered!");
                }
                 // Fade out should happen AFTER potential arrangement
                loadingScreen.classList.add('fade-out');
            };

            loadingManager.onError = function (url) {
                console.error('LoadingManager: Error loading asset: ' + url); // Log: Manager onError
                loadingScreen.textContent = `Error loading asset: ${url}. Check console (F12) & paths.`;
            };

            loadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
                console.log( 'LoadingManager: Loading file: ' + url + ' (' + itemsLoaded + '/' + itemsTotal + ')' ); // Log: Manager onProgress
                loadingScreen.textContent = `Loading: ${itemsLoaded} / ${itemsTotal}`;
            };
            console.log("LoadingManager setup complete."); // Log: Manager setup end
        }

        // --- Asset Loading ---
        function loadAssets() {
            if (!loadingManager) {
                console.error("LoadingManager not initialized before loadAssets() call!");
                return;
            }
            const textureLoader = new THREE.TextureLoader(loadingManager);
            console.log("Starting asset loading process..."); // Log: Asset loading start
            let imageLoadRequests = 0;

            content.forEach((item, index) => {
                if (item.type === 'image') {
                    if (typeof item.src === 'string' && item.src) {
                        imageLoadRequests++;
                        console.log(`[${index}] Requesting load for: ${item.src}`);
                        item.texture = textureLoader.load(
                            item.src,
                            function(texture) {
                                console.log(`[${index}] Successfully loaded texture: ${item.src}`);
                                texture.encoding = THREE.sRGBEncoding;
                                item.texture = texture; // Re-assign to ensure it's the loaded one
                            },
                            undefined, // onProgress
                            function(err) {
                                console.error(`[${index}] Error loading texture: ${item.src}`, err);
                                item.texture = null; // Mark as failed
                            }
                        );
                    } else {
                        console.warn(`[${index}] Invalid or empty image source in content array.`);
                        item.texture = null;
                    }
                }
            });

            console.log(`Requested loading for ${imageLoadRequests} images.`);
            if (imageLoadRequests === 0 && loadingManager) {
                 console.log("No images to load, triggering onLoad manually.");
                 setTimeout(() => {
                    if (!loadingManager.isLoading) {
                        // Check if onLoad has already been called (e.g., by an error)
                        // This is tricky, might need a flag if errors occur.
                        // For now, just call it if not loading.
                        console.log("Manually calling loadingManager.onLoad().");
                        loadingManager.onLoad();
                    }
                 }, 50); // Slightly longer timeout just in case
             } else if (imageLoadRequests > 0) {
                 console.log("Waiting for LoadingManager to complete...");
             }
        }


        // --- Scene Setup ---
        function setupBackground() {
            // ... (le code du fond étoilé reste le même) ...
            const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
            const fragmentShader = `varying vec2 vUv; uniform float time; float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123); } float noise(vec2 st) { vec2 i = floor(st); vec2 f = fract(st); float a = random(i); float b = random(i + vec2(1.0, 0.0)); float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; } float fbm(vec2 st) { float value = 0.0; float amplitude = 0.5; for (int i = 0; i < 6; i++) { value += amplitude * noise(st); st *= 2.0; amplitude *= 0.5; } return value; } void main() { vec2 st = vUv * vec2(4.0, 2.0); vec3 color = vec3(0.01, 0.01, 0.05); float n = fbm(st + vec2(time * 0.05, time * 0.02)); color += vec3(n * 0.2, n * 0.1, n * 0.3); float starDensity = 0.995; float starValue = random(vUv * 1000.0 + sin(time*0.1)); if (starValue > starDensity) { float sparkle = sin(time * 5.0 + vUv.x * 100.0) * 0.5 + 0.5; color += vec3(smoothstep(starDensity, 1.0, starValue)) * (0.8 + sparkle * 0.4); } gl_FragColor = vec4(color, 1.0); }`;
            const bgGeometry = new THREE.SphereGeometry(500, 60, 40);
            bgGeometry.scale(-1, 1, 1);
            const bgMaterial = new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms: { time: { value: 0.0 } }, side: THREE.BackSide });
            const backgroundSphere = new THREE.Mesh(bgGeometry, bgMaterial);
            scene.add(backgroundSphere);
        }

        // --- Content Creation ---
        function createTextCanvas(text, panelWidthPixels, panelHeightPixels, isHeader = false, isCTA = false) {
            // ... (la création du canvas pour le texte reste la même) ...
             const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const resolutionFactor = 3;
            canvas.width = panelWidthPixels * resolutionFactor;
            canvas.height = panelHeightPixels * resolutionFactor;
            context.fillStyle = `rgba(${parseInt(PANEL_COLOR.slice(1, 3), 16)}, ${parseInt(PANEL_COLOR.slice(3, 5), 16)}, ${parseInt(PANEL_COLOR.slice(5, 7), 16)}, ${PANEL_OPACITY})`;
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = TEXT_COLOR;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            let fontSize = TEXT_SIZE * 100 * resolutionFactor;
            if (isHeader) fontSize *= 1.4;
            if (isCTA) fontSize *= 1.2;
            context.font = `bold ${fontSize}px Arial`;
            const lines = text.split('\n');
            const x = canvas.width / 2;
            let y = canvas.height / 2 - (lines.length - 1) * fontSize * 0.6;
            lines.forEach(line => { context.fillText(line, x, y); y += fontSize * 1.2; });
            return canvas;
        }

        function createContentPanel(item, angle, index) {
            let mesh;
            const panelWidthPixels = 512;
            let panelHeight = PANEL_HEIGHT; // Default

            if (item.type === 'text' || item.type === 'header' || item.type === 'cta' || item.type === 'title') {
                 if (item.type === 'title') panelHeight *= 0.5;
                const textCanvas = createTextCanvas(item.text, panelWidthPixels, panelWidthPixels * (panelHeight / PANEL_WIDTH), item.type === 'header', item.type === 'cta');
                const texture = new THREE.CanvasTexture(textCanvas);
                texture.needsUpdate = true;
                const geometry = new THREE.PlaneGeometry(PANEL_WIDTH, panelHeight);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData = { type: 'textPanel', isInteractive: true };

            } else if (item.type === 'image') {
                 if (item.texture && item.texture.image && item.texture.image.naturalWidth > 0) {
                     console.log(`[${index}] Creating panel for loaded image: ${item.src}`);
                     const imgAspect = item.texture.image.naturalWidth / item.texture.image.naturalHeight;
                     panelHeight = PANEL_WIDTH / imgAspect;
                     const geometry = new THREE.PlaneGeometry(PANEL_WIDTH, panelHeight);
                     const material = new THREE.MeshBasicMaterial({ map: item.texture, color: 0xffffff, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
                     mesh = new THREE.Mesh(geometry, material);
                     const bgGeom = new THREE.PlaneGeometry(PANEL_WIDTH * 1.05, panelHeight * 1.05);
                     const bgMat = new THREE.MeshBasicMaterial({ color: new THREE.Color(PANEL_COLOR), transparent: true, opacity: PANEL_OPACITY, side: THREE.DoubleSide });
                     const bgMesh = new THREE.Mesh(bgGeom, bgMat);
                     bgMesh.position.z = -0.01;
                     mesh.add(bgMesh);
                     mesh.userData = { type: 'imagePanel', originalScale: mesh.scale.clone(), isInteractive: true };
                 } else {
                     console.warn(`[${index}] Skipping panel creation for image (texture not ready or invalid): ${item.src}`);
                 }
            }

            if (mesh) {
                const x = Math.sin(angle) * PANEL_RADIUS;
                const z = Math.cos(angle) * PANEL_RADIUS;
                const y = 1.6 + Math.sin(angle * 2 + index * 0.5) * 0.3;
                mesh.position.set(x, y, z);
                mesh.lookAt(camera.position);
                contentGroup.add(mesh);
                if (mesh.userData.isInteractive) {
                     interactiveObjects.push(mesh);
                }
            }
        }

        function arrangeContent() {
            console.log("Arranging content panels..."); // Log: Arrange start
            interactiveObjects = [];
            while(contentGroup.children.length > 0){
                contentGroup.remove(contentGroup.children[0]);
            }

            const totalItems = content.length;
            if (totalItems === 0) {
                 console.log("No content items to arrange.");
                 return;
             }
            const angleSpread = Math.PI * 1.9;
            const angleStep = angleSpread / totalItems;
            let currentAngle = - (angleSpread / 2);

            content.forEach((item, index) => {
                 if (item.type !== 'image' || (item.type === 'image' && item.texture)) {
                    createContentPanel(item, currentAngle, index);
                 } else {
                     console.log(`[${index}] Skipping panel in arrangeContent as texture is missing for ${item.src}`);
                 }
                 currentAngle += angleStep;
            });
             console.log(`Content arrangement complete. ${interactiveObjects.length} interactive objects added.`);
        }


        // --- Interaction ---
        function handleInteractions() {
            // ... (l'interaction reste la même) ...
            const cameraDirection = new THREE.Vector3();
            if (!camera) return; // Guard against camera not being initialized yet
            camera.getWorldDirection(cameraDirection);
            if (!raycaster) return; // Guard against raycaster not being initialized yet
            raycaster.set(camera.position, cameraDirection);
            const intersects = raycaster.intersectObjects(interactiveObjects, true);

            let hitObject = null;
            if (intersects.length > 0) {
                 let firstIntersect = intersects[0].object;
                 while (firstIntersect.parent && firstIntersect.parent !== contentGroup) {
                      if (firstIntersect.userData && firstIntersect.userData.isInteractive) break;
                     firstIntersect = firstIntersect.parent;
                 }
                  if (firstIntersect.userData && firstIntersect.userData.isInteractive) {
                     hitObject = firstIntersect;
                 }
            }

            if (hitObject && INTERSECTED != hitObject) {
                 if (INTERSECTED) {
                     if (INTERSECTED.userData.originalScale) INTERSECTED.scale.copy(INTERSECTED.userData.originalScale);
                     else INTERSECTED.scale.set(1, 1, 1);
                 }
                 INTERSECTED = hitObject;
                 if (INTERSECTED.userData.originalScale) INTERSECTED.scale.copy(INTERSECTED.userData.originalScale).multiplyScalar(INTERACTION_SCALE);
                 else INTERSECTED.scale.set(INTERACTION_SCALE, INTERACTION_SCALE, INTERACTION_SCALE);

            } else if (!hitObject && INTERSECTED) {
                 if (INTERSECTED.userData.originalScale) INTERSECTED.scale.copy(INTERSECTED.userData.originalScale);
                 else INTERSECTED.scale.set(1, 1, 1);
                 INTERSECTED = null;
            }
        }

        // --- Animation & Rendering ---
        function animateBackground(deltaTime) {
             // ... (l'animation du fond reste la même) ...
             const bg = scene?.children.find(obj => obj.material && obj.material.type === 'ShaderMaterial'); // Added optional chaining
            if (bg) {
                bg.material.uniforms.time.value = clock.getElapsedTime();
            }
        }

        function render() {
            // Add guards for critical variables in case render loop starts too early
            if (!renderer || !scene || !camera || !clock) return;

            const deltaTime = clock.getDelta();
            handleInteractions();
            animateBackground(deltaTime);
            renderer.render(scene, camera);
        }

        // --- Event Handlers ---
        function onWindowResize() {
             if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start ---
        // Appel direct à init() car le script est à la fin du body et les scripts externes utilisent defer.
        init();

    </script>

</body>
</html>
