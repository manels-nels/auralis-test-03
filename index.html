<!DOCTYPE html>
<html lang="en">
<head>
    <title>AURALIS VR Experience</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="AURALIS: Step Into Sound and Light. An immersive VR music and video performance by Wang Meng and Yu Miao.">
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; overflow: hidden; background-color: #000; color: #fff; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #vr-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; display: flex; justify-content: center; align-items: center; font-size: 1.5em; z-index: 100; transition: opacity 1s ease-out; }
        #loading-screen.fade-out { opacity: 0; pointer-events: none; }
        canvas { display: block; }
    </style>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- VR Button (Version Spécifique) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/webxr/VRButton.js"></script>
    
</head>
<body>
    <div id="loading-screen">Loading AURALIS Experience...</div>
    <div id="vr-container"></div>

    <script>
        // --- Configuration ---
        const TEXT_COLOR = '#FFFFFF';
        const PANEL_COLOR = '#111133';
        const PANEL_OPACITY = 0.85;
        const TEXT_SIZE = 0.05;
        const PANEL_WIDTH = 2.5;
        const PANEL_HEIGHT = 1.8;
        const PANEL_RADIUS = 5;
        const INTERACTION_SCALE = 1.05;

        // --- Image Assets ---
        console.log("Defining image paths..."); // Log: Start defining paths
        const imagePath_Logo = 'images/logo.jpg';
        const imagePath_WangMeng = 'images/wang_meng.jpg';
        const imagePath_YuMiao = 'images/yu_miao.jpg';
        const imagePath_DJBack = 'images/dj_back.jpg';
        const imagePath_StageWide = 'images/stage_wide.jpg';
        const imagePath_StageDuoBlue = 'images/stage_duo_blue.jpg';
        const imagePath_StageDuoDark = 'images/stage_duo_dark.jpg';
        console.log("Image paths defined."); // Log: Paths defined

        // --- Text Content ---
        const content = [
            // ... (garde le même contenu que dans la version précédente) ...
             { type: 'title', text: "AURALIS" },
            { type: 'image', src: imagePath_Logo, width: 2, height: 2 },
            { type: 'text', text: "Step Into Sound and Light:\nA Journey Beyond Music." },
            { type: 'text', text: "Imagine a space where sound moves like liquid, where music swirls around you, weaving vibration and light. Here, past and future collide, ancient strings resonate against modern frequencies, and visuals pulse in harmony. Welcome to AURALIS!" },
            { type: 'header', text: "The Architects of the Experience" },
            { type: 'text', text: "Wang Meng and Yu Miao dissolve boundaries between past/present, acoustic/digital, East/West. An exploration between the organic and synthetic, tradition and the unknown." },
            { type: 'image', src: imagePath_WangMeng, width: 1, height: 1.2 },
            { type: 'text', text: "• Wang Meng: Visionary audio-visual artist, founder of Atomic Visual Studio, pioneer of stage multimedia. Sculpts light like a painter, breathing life into sound." },
            { type: 'image', src: imagePath_YuMiao, width: 1.5, height: 1 },
            { type: 'text', text: "• Yu Miao: Guzheng virtuoso pushing the ancient zither beyond limits, blending delicate timbre with modern sound design. An emotional current from tradition to the unknown." },
            { type: 'header', text: "A World of Sound, A Canvas of Light" },
            { type: 'image', src: imagePath_StageWide, width: 2, height: 1.1 },
            { type: 'text', text: "Air alive with dazzling visuals extending the sonic experience. Light and movement become instruments, responding to every vibration.\n• Projected visuals morph and evolve, reacting to music.\n• Space transforms as music and light dance, bending perception." },
             { type: 'image', src: imagePath_DJBack, width: 1.8, height: 1 },
            { type: 'text', text: "Manels Favre shapes the experience using SPAT Revolution, freeing sound to move, breathe, and surround you in 3D. Notes appear behind, above, beside you." },
            { type: 'header', text: "A New Way to Experience Music" },
             { type: 'image', src: imagePath_StageDuoBlue, width: 1.8, height: 1.1 },
            { type: 'text', text: "Close your eyes, feel the music flow through you. Open them, you are inside a world where sound and light fuse into a living presence." },
            { type: 'image', src: imagePath_StageDuoDark, width: 1.8, height: 1.1 },
            { type: 'text', text: "A journey into sound, space, and emotion.\nA place where the familiar dissolves.\nA moment that will never happen again." },
            { type: 'cta', text: "Step inside.\nLet yourself be carried away.\n\nComing soon!" }
        ];

        // --- Global Variables ---
        let scene, camera, renderer;
        let INTERSECTED;
        let raycaster;
        let vrButton;
        let loadingManager;
        let contentGroup;
        let interactiveObjects = [];
        let clock;

        // --- Initialization ---
        function init() {
            console.log("Initializing scene..."); // Log: Init start
            clock = new THREE.Clock();
            setupLoadingManager(); // Setup manager first

            scene = new THREE.Scene();
            setupBackground();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('vr-container').appendChild(renderer.domElement);

            vrButton = VRButton.createButton(renderer);
            document.body.appendChild(vrButton);

            const ambientLight = new THREE.AmbientLight(0xCCCCCC, 0.4);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            raycaster = new THREE.Raycaster();
            contentGroup = new THREE.Group();
            scene.add(contentGroup);

            loadAssets(); // Start loading assets

            window.addEventListener('resize', onWindowResize, false);
            renderer.setAnimationLoop(render);
            console.log("Initialization complete."); // Log: Init end
        }

        // --- Loading ---
        function setupLoadingManager() {
            console.log("Setting up LoadingManager..."); // Log: Manager setup start
            loadingManager = new THREE.LoadingManager();
            const loadingScreen = document.getElementById('loading-screen');

            loadingManager.onStart = function ( url, itemsLoaded, itemsTotal ) {
                console.log( 'LoadingManager: Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
            };

            loadingManager.onLoad = function () {
                console.log('LoadingManager: Loading complete!'); // Log: Manager onLoad
                loadingScreen.classList.add('fade-out');
                arrangeContent(); // Arrange content ONLY when loading is fully complete
            };

            loadingManager.onError = function (url) {
                // CRITICAL: This indicates a failure to load an asset
                console.error('LoadingManager: Error loading asset: ' + url); // Log: Manager onError
                loadingScreen.textContent = `Error loading asset: ${url}. Please check console (F12) and file paths.`; // Update message
            };

            loadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
                console.log( 'LoadingManager: Loading file: ' + url + ' (' + itemsLoaded + '/' + itemsTotal + ')' ); // Log: Manager onProgress
                loadingScreen.textContent = `Loading: ${itemsLoaded} / ${itemsTotal}`;
            };
            console.log("LoadingManager setup complete."); // Log: Manager setup end
        }

        // --- Asset Loading ---
        function loadAssets() {
            // Make sure loadingManager exists before creating TextureLoader
            if (!loadingManager) {
                console.error("LoadingManager not initialized before loadAssets() call!");
                return;
            }
            const textureLoader = new THREE.TextureLoader(loadingManager); // Pass manager here
            console.log("Starting asset loading process..."); // Log: Asset loading start

            let imageLoadRequests = 0; // Count how many images we try to load

            content.forEach((item, index) => {
                if (item.type === 'image') {
                    if (typeof item.src === 'string' && item.src) {
                        imageLoadRequests++;
                        console.log(`[${index}] Requesting load for: ${item.src}`); // Log: Requesting image
                        item.texture = textureLoader.load(
                            item.src,
                            // onLoad callback (per texture)
                            function(texture) {
                                console.log(`[${index}] Successfully loaded texture: ${item.src}`); // Log: Texture success
                                texture.encoding = THREE.sRGBEncoding;
                                // Store the loaded texture back into the content item
                                item.texture = texture;
                            },
                            // onProgress callback (per texture - usually not needed)
                            undefined,
                            // onError callback (per texture)
                            function(err) {
                                // CRITICAL: This specific image failed
                                console.error(`[${index}] Error loading texture: ${item.src}`, err); // Log: Texture error
                                // Set texture to null or a fallback placeholder if you have one
                                item.texture = null;
                                // Note: The global LoadingManager.onError will also fire.
                            }
                        );
                    } else {
                        console.warn(`[${index}] Invalid or empty image source in content array.`); // Log: Invalid src
                        item.texture = null; // Ensure it's null if src is invalid
                    }
                }
            });

            console.log(`Requested loading for ${imageLoadRequests} images.`); // Log: Total requested

             // If no images were requested at all, the LoadingManager might not fire onLoad.
             // We need to manually trigger the completion steps in this edge case.
             if (imageLoadRequests === 0 && loadingManager) {
                 console.log("No images to load, triggering onLoad manually."); // Log: Manual trigger
                 // Use setTimeout to ensure this runs after the current execution stack clears
                 // and gives the manager a chance if it somehow started.
                 setTimeout(() => {
                    if (!loadingManager.isLoading) { // Check if the manager is truly idle
                        loadingManager.onLoad();
                    }
                 }, 0);
             }
        }


        // --- Scene Setup ---
        function setupBackground() {
            // ... (le code du fond étoilé reste le même) ...
            const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
            const fragmentShader = `varying vec2 vUv; uniform float time; float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123); } float noise(vec2 st) { vec2 i = floor(st); vec2 f = fract(st); float a = random(i); float b = random(i + vec2(1.0, 0.0)); float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; } float fbm(vec2 st) { float value = 0.0; float amplitude = 0.5; for (int i = 0; i < 6; i++) { value += amplitude * noise(st); st *= 2.0; amplitude *= 0.5; } return value; } void main() { vec2 st = vUv * vec2(4.0, 2.0); vec3 color = vec3(0.01, 0.01, 0.05); float n = fbm(st + vec2(time * 0.05, time * 0.02)); color += vec3(n * 0.2, n * 0.1, n * 0.3); float starDensity = 0.995; float starValue = random(vUv * 1000.0 + sin(time*0.1)); if (starValue > starDensity) { float sparkle = sin(time * 5.0 + vUv.x * 100.0) * 0.5 + 0.5; color += vec3(smoothstep(starDensity, 1.0, starValue)) * (0.8 + sparkle * 0.4); } gl_FragColor = vec4(color, 1.0); }`;
            const bgGeometry = new THREE.SphereGeometry(500, 60, 40);
            bgGeometry.scale(-1, 1, 1);
            const bgMaterial = new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms: { time: { value: 0.0 } }, side: THREE.BackSide });
            const backgroundSphere = new THREE.Mesh(bgGeometry, bgMaterial);
            scene.add(backgroundSphere);
        }

        // --- Content Creation ---
        function createTextCanvas(text, panelWidthPixels, panelHeightPixels, isHeader = false, isCTA = false) {
            // ... (la création du canvas pour le texte reste la même) ...
             const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const resolutionFactor = 3;
            canvas.width = panelWidthPixels * resolutionFactor;
            canvas.height = panelHeightPixels * resolutionFactor;
            context.fillStyle = `rgba(${parseInt(PANEL_COLOR.slice(1, 3), 16)}, ${parseInt(PANEL_COLOR.slice(3, 5), 16)}, ${parseInt(PANEL_COLOR.slice(5, 7), 16)}, ${PANEL_OPACITY})`;
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = TEXT_COLOR;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            let fontSize = TEXT_SIZE * 100 * resolutionFactor;
            if (isHeader) fontSize *= 1.4;
            if (isCTA) fontSize *= 1.2;
            context.font = `bold ${fontSize}px Arial`;
            const lines = text.split('\n');
            const x = canvas.width / 2;
            let y = canvas.height / 2 - (lines.length - 1) * fontSize * 0.6;
            lines.forEach(line => { context.fillText(line, x, y); y += fontSize * 1.2; });
            return canvas;
        }

        function createContentPanel(item, angle, index) {
            let mesh;
            const panelWidthPixels = 512;
            let panelHeight = PANEL_HEIGHT; // Default

            if (item.type === 'text' || item.type === 'header' || item.type === 'cta' || item.type === 'title') {
                // ... (création panneau texte reste la même) ...
                 if (item.type === 'title') panelHeight *= 0.5;
                const textCanvas = createTextCanvas(item.text, panelWidthPixels, panelWidthPixels * (panelHeight / PANEL_WIDTH), item.type === 'header', item.type === 'cta');
                const texture = new THREE.CanvasTexture(textCanvas);
                texture.needsUpdate = true;
                const geometry = new THREE.PlaneGeometry(PANEL_WIDTH, panelHeight);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData = { type: 'textPanel', isInteractive: true };

            } else if (item.type === 'image') {
                 // IMPORTANT: Check if texture loaded successfully *and* has image data
                 if (item.texture && item.texture.image && item.texture.image.naturalWidth > 0) {
                     console.log(`[${index}] Creating panel for loaded image: ${item.src}`); // Log: Creating image panel
                     const imgAspect = item.texture.image.naturalWidth / item.texture.image.naturalHeight;
                     panelHeight = PANEL_WIDTH / imgAspect;

                     const geometry = new THREE.PlaneGeometry(PANEL_WIDTH, panelHeight);
                     const material = new THREE.MeshBasicMaterial({ map: item.texture, color: 0xffffff, transparent: true, opacity: 1.0, side: THREE.DoubleSide });
                     mesh = new THREE.Mesh(geometry, material);

                     // Add background
                     const bgGeom = new THREE.PlaneGeometry(PANEL_WIDTH * 1.05, panelHeight * 1.05);
                     const bgMat = new THREE.MeshBasicMaterial({ color: new THREE.Color(PANEL_COLOR), transparent: true, opacity: PANEL_OPACITY, side: THREE.DoubleSide });
                     const bgMesh = new THREE.Mesh(bgGeom, bgMat);
                     bgMesh.position.z = -0.01;
                     mesh.add(bgMesh);
                     mesh.userData = { type: 'imagePanel', originalScale: mesh.scale.clone(), isInteractive: true };

                 } else {
                     // Image failed to load or src was invalid
                     console.warn(`[${index}] Skipping panel creation for image (texture not ready or invalid): ${item.src}`); // Log: Skipping failed image panel
                     // Do not create a mesh, or create a visible placeholder if desired
                     // return; // Exit without creating a mesh for this item
                 }
            }

            // Position and add the mesh if it was created
            if (mesh) {
                const x = Math.sin(angle) * PANEL_RADIUS;
                const z = Math.cos(angle) * PANEL_RADIUS;
                const y = 1.6 + Math.sin(angle * 2 + index * 0.5) * 0.3;
                mesh.position.set(x, y, z);
                mesh.lookAt(camera.position);
                contentGroup.add(mesh);
                if (mesh.userData.isInteractive) {
                     interactiveObjects.push(mesh);
                }
            }
        }

        function arrangeContent() {
            console.log("Arranging content panels..."); // Log: Arrange start
            // Clear previous content (safer if called multiple times)
            interactiveObjects = [];
            while(contentGroup.children.length > 0){
                const child = contentGroup.children[0];
                contentGroup.remove(child);
                // Optional: Dispose geometry/material if needed, but usually okay
            }

            const totalItems = content.length;
            if (totalItems === 0) {
                 console.log("No content items to arrange."); // Log: No content
                 return;
             }
            const angleSpread = Math.PI * 1.9;
            const angleStep = angleSpread / totalItems;
            let currentAngle = - (angleSpread / 2);

            content.forEach((item, index) => {
                 // Check again if texture exists for images before creating panel
                 if (item.type !== 'image' || (item.type === 'image' && item.texture)) {
                    createContentPanel(item, currentAngle, index);
                 } else {
                     console.log(`[${index}] Skipping panel in arrangeContent as texture is missing for ${item.src}`);
                 }
                 currentAngle += angleStep;
            });
             console.log(`Content arrangement complete. ${interactiveObjects.length} interactive objects added.`); // Log: Arrange end
        }


        // --- Interaction ---
        function handleInteractions() {
            // ... (l'interaction reste la même) ...
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            raycaster.set(camera.position, cameraDirection);
            const intersects = raycaster.intersectObjects(interactiveObjects, true);

            let hitObject = null;
            if (intersects.length > 0) {
                 let firstIntersect = intersects[0].object;
                 while (firstIntersect.parent && firstIntersect.parent !== contentGroup) {
                      if (firstIntersect.userData && firstIntersect.userData.isInteractive) break;
                     firstIntersect = firstIntersect.parent;
                 }
                  if (firstIntersect.userData && firstIntersect.userData.isInteractive) {
                     hitObject = firstIntersect;
                 }
            }

            if (hitObject && INTERSECTED != hitObject) {
                 if (INTERSECTED) {
                     if (INTERSECTED.userData.originalScale) INTERSECTED.scale.copy(INTERSECTED.userData.originalScale);
                     else INTERSECTED.scale.set(1, 1, 1);
                 }
                 INTERSECTED = hitObject;
                 if (INTERSECTED.userData.originalScale) INTERSECTED.scale.copy(INTERSECTED.userData.originalScale).multiplyScalar(INTERACTION_SCALE);
                 else INTERSECTED.scale.set(INTERACTION_SCALE, INTERACTION_SCALE, INTERACTION_SCALE);

            } else if (!hitObject && INTERSECTED) {
                 if (INTERSECTED.userData.originalScale) INTERSECTED.scale.copy(INTERSECTED.userData.originalScale);
                 else INTERSECTED.scale.set(1, 1, 1);
                 INTERSECTED = null;
            }
        }

        // --- Animation & Rendering ---
        function animateBackground(deltaTime) {
             // ... (l'animation du fond reste la même) ...
             const bg = scene.children.find(obj => obj.material && obj.material.type === 'ShaderMaterial');
            if (bg) {
                bg.material.uniforms.time.value = clock.getElapsedTime();
            }
        }

        function render() {
            const deltaTime = clock.getDelta();
            handleInteractions();
            animateBackground(deltaTime);
            renderer.render(scene, camera);
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start ---
        // Ensure the DOM is ready before initializing (optional but good practice)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>
</body>
</html>
